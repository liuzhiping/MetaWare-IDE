;HEADER*******************************************************************
;****************************************************************************
;**
;** Copyright (c) 1989-2007 ARC International.
;** All rights reserved                                          
;**                                                              
;** This software embodies materials and concepts which are      
;** confidential to ARC International and is made
;** available solely pursuant to the terms of a written license   
;** agreement with ARC International             
;**
;** File: psp_prv.met
;**
;** Comments:      
;**   This assembler header file contains private declarations for 
;** use with the mqx assembler files
;**                                                               
;**
;*************************************************************************
;END**********************************************************************

;------------------------------------------------------------------------
;                       IMPORTS
;
; pspcont.s is automatically generated by the MetaWare compiler when
; it compiles psp_ctx.c.  We do this because ARC is so configurable.
; We'd like to tools themselves to define the field offsets rather
; than having to do it by hand.  What makes this nice is that we can
; #ifdef parts of the register save structures in the C source code
; and the assembly register save/restore routines are automatically
; configured identically.  A new pragma asm_field_offsets was added to
; the MetaWare compiler to support this.  You will need to upgrade
; your compiler "front end" if it does not recognize this pragma.

.include "./pspcont.s"

;------------------------------------------------------------------------
;                       CONSTANT DECLARATIONS
;

; The following are the bits in the CONFIG field of the kernel data structure
; to set for the psp options.
; NOTE: These must agree with values in mqx_prv.h

.equ MQX_CNFG2_PSP_ASM_KERNEL_LOGGING,               0x00008000
.equ MQX_CNFG2_PSP_ASM_FP_REGISTERS_EXIST,           0x00004000
.equ MQX_CNFG2_PSP_ASM_MMU_CONTEXT_EXIST,            0x00002000
.equ MQX_CNFG2_PSP_ASM_PROFILING_ENABLED,            0x00001000
.equ MQX_CNFG2_PSP_ASM_RUN_TIME_ERR_CHECK_ENABLED,   0x00000800
.equ MQX_CNFG2_PSP_ASM_DSP_REGISTERS_EXIST,          0x00000400

.equ PSP_SR32_AE_BIT, 5
.equ PSP_SR32_A2_BIT, 4
.equ PSP_SR32_A1_BIT, 3

; code cache alignment
.ifndef MQX_CODE_ALIGNMENT
.equ MQX_CODE_ALIGNMENT,4
.endif

.if MQX_KERNEL_LOGGING
.equ KLOG_CNFG,MQX_CNFG2_PSP_ASM_KERNEL_LOGGING
.else
.equ KLOG_CNFG,0
.endif

.if MQX_FP_REGISTERS_EXIST
.equ FP_CNFG,MQX_CNFG2_PSP_ASM_FP_REGISTERS_EXIST
.else
.equ FP_CNFG,0
.endif

.if MQX_DSP_REGISTERS_EXIST
.equ DSP_CNFG,MQX_CNFG2_PSP_ASM_DSP_REGISTERS_EXIST
.else
.equ DSP_CNFG,0
.endif

.equ PSP_CNFG2,KLOG_CNFG|FP_CNFG|DSP_CNFG

;  Task FLAGS bits
;  These must match definitions in mqx_prv.h
.equ PREEMPTION_DISABLED,0x1000
.equ SCRATCH_REGISTERS_SAVED,0x0040
.equ FP_TASK,0x0002
.equ FP_CONTEXT_SAVED,0x0200
.equ DSP_TASK,0x0008
.equ DSP_CONTEXT_SAVED,0x0100


;------------------------------------------------------------------------

.set PSP_EXTENSION_REGISTERS_OFFSET,R27_LOC+4
.if PSP_EXTENSION_REGISTERS & 0x00000001
.extCoreRegister R32, 32, r|w, can_shortcut  
.equ R32_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000002
.extCoreRegister R33, 33, r|w, can_shortcut  
.equ R33_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000004
.extCoreRegister R34, 34, r|w, can_shortcut  
.equ R34_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000008
.extCoreRegister R35, 35, r|w, can_shortcut  
.equ R35_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000010
.extCoreRegister R36, 36, r|w, can_shortcut  
.equ R36_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000020
.extCoreRegister R37, 37, r|w, can_shortcut  
.equ R37_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000040
.extCoreRegister R38, 38, r|w, can_shortcut  
.equ R38_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000080
.extCoreRegister R39, 39, r|w, can_shortcut  
.equ R39_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000100
.extCoreRegister R40, 40, r|w, can_shortcut  
.equ R40_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000200
.extCoreRegister R41, 41, r|w, can_shortcut  
.equ R41_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000400
.extCoreRegister R42, 42, r|w, can_shortcut  
.equ R42_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00000800
.extCoreRegister R43, 43, r|w, can_shortcut  
.equ R43_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00001000
.extCoreRegister R44, 44, r|w, can_shortcut  
.equ R44_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00002000
.extCoreRegister R45, 45, r|w, can_shortcut  
.equ R45_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00004000
.extCoreRegister R46, 46, r|w, can_shortcut  
.equ R46_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00008000
.extCoreRegister R47, 47, r|w, can_shortcut  
.equ R47_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00010000
.extCoreRegister R48, 48, r|w, can_shortcut  
.equ R48_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00020000
.extCoreRegister R49, 49, r|w, can_shortcut  
.equ R49_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00040000
.extCoreRegister R50, 50, r|w, can_shortcut  
.equ R50_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00080000
.extCoreRegister R51, 51, r|w, can_shortcut  
.equ R51_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00100000
.extCoreRegister R52, 52, r|w, can_shortcut  
.equ R52_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00200000
.extCoreRegister R53, 53, r|w, can_shortcut  
.equ R53_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00400000
.extCoreRegister R54, 54, r|w, can_shortcut  
.equ R54_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x00800000
.extCoreRegister R55, 55, r|w, can_shortcut  
.equ R55_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x01000000
.extCoreRegister R56, 56, r|w, can_shortcut  
.equ R56_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x02000000
.extCoreRegister R57, 57, r|w, can_shortcut  
.equ R57_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x04000000
.extCoreRegister R58, 58, r|w, can_shortcut  
.equ R58_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif
.if PSP_EXTENSION_REGISTERS & 0x08000000
.extCoreRegister R59, 59, r|w, can_shortcut  
.equ R59_LOC,PSP_EXTENSION_REGISTERS_OFFSET
.set PSP_EXTENSION_REGISTERS_OFFSET,PSP_EXTENSION_REGISTERS_OFFSET+4
.endif

; Define the size of the context save structure as defined by ./pspcont.s
.set CONTEXT_SIZE,PSP_BLOCKED_STACK_STRUCT_LAST_FIELD_LOC


;------------------------------------------------------------------------
;                          MACRO DECLARATIONS
;

; This macro returns the address of the kernel data in the specified register
.macro GET_KERNEL_DATA
   ld  %r2,[_mqx_kernel_data]
.endm

; This macro conditionaly saves an extended register
.macro SAVEX, REG, LOC, BITS
.if PSP_EXTENSION_REGISTERS & \&BITS
   st \&REG,[%r0,\&LOC]
.endif
.endm

; This macro conditionaly loads an extended register
.macro LOADX, REG, LOC, BITS
.if PSP_EXTENSION_REGISTERS & \&BITS
; Start CR 2221
;   ld \&REG,[%sp,\&LOC]
   ld %r14,[%sp,\&LOC]
   mov \&REG,%r14
; End CR 2221
.endif
.endm

; This macro restores the XMAC state if present
.macro SAVE_XMAC_REGISTERS
   .ifdef AUX_MACMODE_LOC
   lr	%r3,[PSP_AUX_MACMODE]
   st	%r3,[%sp,AUX_MACMODE_LOC]
   .endif
   .ifdef CORE_ACC1_R56_LOC
   st	%acc1,[%sp,CORE_ACC1_R56_LOC]
   .endif
   .ifdef CORE_ACC2_R57_LOC
   st	%acc2,[%sp,CORE_ACC2_R57_LOC]
   .endif
   .ifdef AUX_XMAC0_16_LOC
   lr 	%r3,[PSP_AUX_XMAC0_16]
   st	%r3,[%sp,AUX_XMAC0_16_LOC]
   .endif  
   .ifdef AUX_XMAC1_16_LOC
   lr 	%r3,[PSP_AUX_XMAC1_16]
   st	%r3,[%sp,AUX_XMAC1_16_LOC]
   .endif
   .ifdef AUX_XMAC2_16_LOC
   lr 	%r3,[PSP_AUX_XMAC2_16]
   st	%r3,[%sp,AUX_XMAC2_16_LOC]
   .endif
  ; Start CR 2180 - Save Xmul32x16 register
  .ifdef __Xmul32x16 
   .ifdef AUX_XMACLW_H_LOC
   lr 	%r3,[PSP_AUX_XMACLW_H]
   st	%r3,[%sp,AUX_XMACLW_H_LOC]
   .endif
   .ifdef AUX_XMACLW_L_LOC
   lr 	%r3,[PSP_AUX_XMACLW_L]
   st	%r3,[%sp,AUX_XMACLW_L_LOC]
   .endif
  .endif 
  ; End CR 2180
  .ifdef __Xxmac_24
   .ifdef AUX_XMAC0_24_LOC
   lr 	%r3,[PSP_AUX_XMAC0_24]
   st	%r3,[%sp,AUX_XMAC0_24_LOC]
   .endif
   .ifdef AUX_XMAC1_24_LOC
   lr 	%r3,[PSP_AUX_XMAC1_24]
   st	%r3,[%sp,AUX_XMAC1_24_LOC]
   .endif
   .ifdef AUX_XMAC2_24_LOC
   lr 	%r3,[PSP_AUX_XMAC2_24]
   st	%r3,[%sp,AUX_XMAC2_24_LOC]
   .endif
  .endif
.endm

; This macro restores the XMAC state if present
.macro RESTORE_XMAC_REGISTERS
   .ifdef AUX_MACMODE_LOC
   ld	%r0,[%sp, AUX_MACMODE_LOC]
   sr	%r0,[PSP_AUX_MACMODE]
   .endif
   .ifdef CORE_ACC1_R56_LOC
   ld	%r0,[%sp, CORE_ACC1_R56_LOC]
   mov	%acc1,%r0
   .endif
   .ifdef CORE_ACC2_R57_LOC
   ld	%r0,[%sp, CORE_ACC2_R57_LOC]
   mov	%acc2,%r0
   .endif
   ; Start CR 2210
   ;.ifdef AUX_XMAC0_16_LOC
   ;ld	%r0,[%sp, AUX_XMAC0_16_LOC]
   ;sr	%r0,[PSP_AUX_XMAC0_16]
   ;.endif
   ; End CR 2210
   .ifdef AUX_XMAC1_16_LOC
   ld	%r0,[%sp, AUX_XMAC1_16_LOC]
   sr	%r0,[PSP_AUX_XMAC1_16]
   .endif
   .ifdef AUX_XMAC2_16_LOC
   ld	%r0,[%sp, AUX_XMAC2_16_LOC]
   sr	%r0,[PSP_AUX_XMAC2_16]
   .endif
   ; Start CR 2210
   .ifdef AUX_XMAC0_16_LOC
   ld	%r0,[%sp, AUX_XMAC0_16_LOC]
   sr	%r0,[PSP_AUX_XMAC0_16]
   .endif
   ; End CR 2210
  ; Start CR 2180 - Restore Xmul32x16 register
  .ifdef __Xmul32x16 
   .ifdef AUX_XMACLW_H_LOC
   ld	%r0,[%sp, AUX_XMACLW_H_LOC]
   sr	%r0,[PSP_AUX_XMACLW_H]
   .endif
   .ifdef AUX_XMACLW_L_LOC
   ld	%r0,[%sp, AUX_XMACLW_L_LOC]
   sr	%r0,[PSP_AUX_XMACLW_L]
   .endif
  .endif 
  ; End CR 2180
  .ifdef __Xxmac_24
   .ifdef AUX_XMAC0_24_LOC
   ld	%r0,[%sp, AUX_XMAC0_24_LOC]
   sr	%r0,[PSP_AUX_XMAC0_24]
   .endif
   .ifdef AUX_XMAC1_24_LOC
   ld	%r0,[%sp, AUX_XMAC1_24_LOC]
   sr	%r0,[PSP_AUX_XMAC1_24]
   .endif
   .ifdef AUX_XMAC2_24_LOC
   ld	%r0,[%sp, AUX_XMAC2_24_LOC]
   sr	%r0,[PSP_AUX_XMAC2_24]
   .endif
  .endif
.endm


; This macro saves the context for the running task when called from a C 
; function. Since it is called from a C function, the C scratch registers
; do not have to be saved
.macro SAVE_NONSCRATCH_REGISTERS
   sub  %sp,%sp,CONTEXT_SIZE
   lr   %r0,[STATUS32]
   st_s %r0,[%sp,FLAGS_LOC]
   st   %BLINK,[%sp,RETURN_ADDRESS_LOC]
   st   %BLINK,[%sp,BLINK_LOC]
   lr   %r0,[LP_START]
   st_s %r0,[%sp,LP_START_LOC]
   lr   %r0,[LP_END]
   st_s %r0,[%sp,LP_END_LOC]
   st_s %r13,[%sp,R13_LOC]
   st_s %r14,[%sp,R14_LOC]
   st_s %r15,[%sp,R15_LOC]
   st   %r60,[%sp,LP_COUNT_LOC]
   st   %r16,[%sp,R16_LOC]
   st   %r17,[%sp,R17_LOC]
   st   %r18,[%sp,R18_LOC]
   st   %r19,[%sp,R19_LOC]
   st   %r20,[%sp,R20_LOC]
   st   %r21,[%sp,R21_LOC]
   st   %r22,[%sp,R22_LOC]
   st   %r23,[%sp,R23_LOC]
   st   %r24,[%sp,R24_LOC]
   st   %r25,[%sp,R25_LOC]
   st   %r26,[%sp,R26_LOC]
   st   %r27,[%sp,R27_LOC]
   add  %r0,%sp,R27_LOC
   SAVEX %R32,R32_LOC-R27_LOC,0x00000001
   SAVEX %R33,R33_LOC-R27_LOC,0x00000002
   SAVEX %R34,R34_LOC-R27_LOC,0x00000004
   SAVEX %R35,R35_LOC-R27_LOC,0x00000008
   SAVEX %R36,R36_LOC-R27_LOC,0x00000010
   SAVEX %R37,R37_LOC-R27_LOC,0x00000020
   SAVEX %R38,R38_LOC-R27_LOC,0x00000040
   SAVEX %R39,R39_LOC-R27_LOC,0x00000080
   SAVEX %R40,R40_LOC-R27_LOC,0x00000100
   SAVEX %R41,R41_LOC-R27_LOC,0x00000200
   SAVEX %R42,R42_LOC-R27_LOC,0x00000400
   SAVEX %R43,R43_LOC-R27_LOC,0x00000800
   SAVEX %R44,R44_LOC-R27_LOC,0x00001000
   SAVEX %R45,R45_LOC-R27_LOC,0x00002000
   SAVEX %R46,R46_LOC-R27_LOC,0x00004000
   SAVEX %R47,R47_LOC-R27_LOC,0x00008000
   SAVEX %R48,R48_LOC-R27_LOC,0x00010000
   SAVEX %R49,R49_LOC-R27_LOC,0x00020000
   SAVEX %R50,R50_LOC-R27_LOC,0x00040000
   SAVEX %R51,R51_LOC-R27_LOC,0x00080000
   SAVEX %R52,R52_LOC-R27_LOC,0x00100000
   SAVEX %R53,R53_LOC-R27_LOC,0x00200000
   SAVEX %R54,R54_LOC-R27_LOC,0x00400000
   SAVEX %R55,R55_LOC-R27_LOC,0x00800000
   SAVEX %R56,R56_LOC-R27_LOC,0x01000000
   SAVEX %R57,R57_LOC-R27_LOC,0x02000000
   SAVEX %R58,R58_LOC-R27_LOC,0x04000000
   SAVEX %R59,R59_LOC-R27_LOC,0x08000000
.endm

; This macro restores the context for a task
.macro RESTORE_ALL_REGISTERS
   LOADX %R32,R32_LOC,0x00000001
   LOADX %R33,R33_LOC,0x00000002
   LOADX %R34,R34_LOC,0x00000004
   LOADX %R35,R35_LOC,0x00000008
   LOADX %R36,R36_LOC,0x00000010
   LOADX %R37,R36_LOC,0x00000020
   LOADX %R38,R38_LOC,0x00000040
   LOADX %R39,R39_LOC,0x00000080
   LOADX %R40,R40_LOC,0x00000100
   LOADX %R41,R41_LOC,0x00000200
   LOADX %R42,R42_LOC,0x00000400
   LOADX %R43,R43_LOC,0x00000800
   LOADX %R44,R44_LOC,0x00001000
   LOADX %R45,R45_LOC,0x00002000
   LOADX %R46,R46_LOC,0x00004000
   LOADX %R47,R47_LOC,0x00008000
   LOADX %R48,R48_LOC,0x00010000
   LOADX %R49,R49_LOC,0x00020000
   LOADX %R50,R50_LOC,0x00040000
   LOADX %R51,R51_LOC,0x00080000
   LOADX %R52,R52_LOC,0x00100000
   LOADX %R53,R53_LOC,0x00200000
   LOADX %R54,R54_LOC,0x00400000
   LOADX %R55,R55_LOC,0x00800000
   LOADX %R56,R56_LOC,0x01000000
.ifdef __Xmult32
   ld     %r0,[%sp,R57_LOC]
   ld     %r1,[%sp,R59_LOC]
   mulu64 0, %r0, 1
   ; ld     %r60,[%sp,LP_COUNT_LOC]
   ld     %r14,[%sp,LP_COUNT_LOC]
   mov    %r60,%r14
   mov    0,%mlo
   sr     %r1,[0x12]
.else
   LOADX %R57,R57_LOC,0x02000000
   LOADX %R58,R58_LOC,0x04000000
   LOADX %R59,R59_LOC,0x08000000
   ; ld    %r60,[%sp,LP_COUNT_LOC]
   ld    %r14,[%sp,LP_COUNT_LOC]
   mov   %r60,%r14
.endif
   ld_s  %r0,[%sp,LP_START_LOC]
   ld_s  %r13,[%sp,R13_LOC]
   ld_s  %r14,[%sp,R14_LOC]
   sr    %r0,[LP_START]
   ld_s  %r0,[%sp,LP_END_LOC]
   ld_s  %r15,[%sp,R15_LOC]
   ld    %r16,[%sp,R16_LOC]
   sr    %r0,[LP_END]
   ld_s  %r0,[%sp,BLINK_LOC]
   ld    %r17,[%sp,R17_LOC]
   ld    %r18,[%sp,R18_LOC]
   mov_s %BLINK,%r0
   ld    %r19,[%sp,R19_LOC]
   ld    %r20,[%sp,R20_LOC]
   ld    %r21,[%sp,R21_LOC]
   ld    %r22,[%sp,R22_LOC]
   ld    %r23,[%sp,R23_LOC]
   ld    %r24,[%sp,R24_LOC]
   ld    %r0,[%r3,TD_FLAGS]
   ld    %r25,[%sp,R25_LOC]
   and.f %r1,%r0,SCRATCH_REGISTERS_SAVED
   ld    %r26,[%sp,R26_LOC]
   beq.d no_scratch_to_load
   ld    %r27,[%sp,R27_LOC]

   bic   %r0,%r0,SCRATCH_REGISTERS_SAVED
   st    %r0,[%r3,TD_FLAGS]
   RESTORE_XMAC_REGISTERS
   ld_s %r1,[%sp,R1_LOC]
   ld_s %r2,[%sp,R2_LOC]
   ld_s %r3,[%sp,R3_LOC]
   ld   %r4,[%sp,R4_LOC]
   ld   %r5,[%sp,R5_LOC]
   ld   %r6,[%sp,R6_LOC]
   ld   %r7,[%sp,R7_LOC]
   ld   %r8,[%sp,R8_LOC]
   ld   %r9,[%sp,R9_LOC]
   ld   %r10,[%sp,R10_LOC]
   ld   %r11,[%sp,R11_LOC]
   ld_s %r12,[%sp,R12_LOC]
no_scratch_to_load:

   ld_s  %r0,[%sp,ILINK1_LOC]
   flag  0                     ; STOP ALLL INTERRUPTS
   mov_s %ILINK1,%r0
   ld_s  %r0,[%sp,FLAGS_LOC]
   sr    %r0,[STATUS32_L2]
   ld_s  %r0,[%sp,RETURN_ADDRESS_LOC]
   mov_s %ILINK2,%r0
   ; Start CR 2212 - Restore BTA register
   .ifdef BTA_LOC
   ld    %r0,[%sp,BTA_LOC]
   sr    %r0,[bta_l2]
   .endif
   ; End CR 2212
   ld_s  %r0,[%sp,R0_LOC]
.endm


.ifdef BTA_LOC

 .macro SAVE_BTA_EXCEPTION_STATE
   lr     %r0,[STATUS32]
   mov_s  %r12,0	; Specify ENABLE_SR should be 0
   bbit0  %r0,PSP_SR32_AE_BIT, 2f ; branch if not exception (STATUS[AE])
    ;; Save state for an exception
1: lr     %r0,[eret]
   st     %r0,[%sp,RETURN_ADDRESS_LOC]
   lr     %r0,[erstatus]
   st_s   %r0,[%sp,FLAGS_LOC]
   lr     %r0,[erbta]
   bra.d  int_save_level_done
   st     %r0,[%sp,BTA_LOC]
2: bbit0  %r0,PSP_SR32_A2_BIT, 3f ; branch if not level2 (STATUS[A2])
    ;; Save state for a level2 interrupt
   lr     %r0,[STATUS32_L2]
   st_s   %r0,[%sp,FLAGS_LOC]
   st     %ilink2,[%sp,RETURN_ADDRESS_LOC]
   lr     %r0,[bta_l2]
   bra.d  int_save_level_done
   st     %r0,[%sp,BTA_LOC]
   ;; Is it possible to have all bits clear?
3: bbit0  %r0,PSP_SR32_A1_BIT, 1b ; branch if not level1 (STATUS[A1])
    ;; Save state for a level1 interrupt
   lr     %r0,[STATUS32_L1]
   st_s   %r0,[%sp,FLAGS_LOC]
   st     %ilink1,[%sp,RETURN_ADDRESS_LOC]
   lr     %r0,[bta_l1]
   st     %r0,[%sp,BTA_LOC]
   bra.d  int_save_level_done
   mov_s  %r12,0x4	; Specify ENABLE_SR should be 4
 .endm

.else

 .equ IRQ_LV12,0x43
 .macro SAVE_A5_A6_EXCEPTION_STATE
   sub.f  0,%r1,2
   ble.d  int_save_level2
   lr     %r0,[IRQ_LV12] ; sticky bits that need to be cleared
   and.f  0,%r0,2
   beq.d  int_save_level1
int_save_level2:
   sr     %r0,[IRQ_LV12]
   lr     %r0,[STATUS32_L2]
   st_s   %r0,[%sp,FLAGS_LOC]
   st     %ilink2,[%sp,RETURN_ADDRESS_LOC]
   bra.d  int_save_level_done
   mov_s  %r12,0	; Specify ENABLE_SR should be 0
int_save_level1:
   mov_s  %r12,0x4	; Specify ENABLE_SR should be 4 (only allow level 2 interrupts)
   lr     %r0,[STATUS32_L1]
   st_s   %r0,[%sp,FLAGS_LOC]
   st     %ilink1,[%sp,RETURN_ADDRESS_LOC]
 .endm

.endif

.macro SAVE_ISR_REGISTERS
   sub    %sp,%sp,CONTEXT_SIZE
   st_s   %r0,[%sp,R0_LOC]
   st_s   %r12,[%sp,R12_LOC]

.ifdef BTA_LOC
   SAVE_BTA_EXCEPTION_STATE
.else
   SAVE_A5_A6_EXCEPTION_STATE
.endif

int_save_level_done:
   st   %ILINK1,[%sp,ILINK1_LOC]
   st_s %r2,[%sp,R2_LOC]
   GET_KERNEL_DATA                      ; get the kernel data address
   st   %r60,[%sp,LP_COUNT_LOC]
   lr   %r0,[LP_START]
   st_s %r0,[%sp,LP_START_LOC]
   lr   %r0,[LP_END]
   st_s %r0,[%sp,LP_END_LOC]
   st   %BLINK,[%sp,BLINK_LOC]
; R1 saved by interrupt prolog, and contains int vector #
   st_s %r3,[%sp,R3_LOC]
   st   %r4,[%sp,R4_LOC]
   mov_s%r4,%r1             ; Put int# into R4
   st   %r5,[%sp,R5_LOC]
   st   %r6,[%sp,R6_LOC]
   st   %r7,[%sp,R7_LOC]
   st   %r8,[%sp,R8_LOC]
   st   %r9,[%sp,R9_LOC]
   st   %r10,[%sp,R10_LOC]
   st   %r11,[%sp,R11_LOC]
   st   %r27,[%sp,R27_LOC]
   add  %r0,%sp,R27_LOC     ; needed by SAVE_XMAC_REGISTERS too
.ifdef __Xmult32
   SAVEX %R57,R57_LOC-R27_LOC,0x02000000
   SAVEX %R59,R59_LOC-R27_LOC,0x08000000
.endif
   SAVE_XMAC_REGISTERS
.endm

.macro RESTORE_ISR_REGISTERS
   RESTORE_XMAC_REGISTERS

   ld_s %r1,[%sp,R1_LOC]
   ld_s %r2,[%sp,R2_LOC]
   ld_s %r0,[%sp,BLINK_LOC]
   ld_s %r3,[%sp,R3_LOC]
   ld   %r4,[%sp,R4_LOC]
   mov_s%BLINK,%r0
   ld   %r7,[%sp,R7_LOC]
   ld_s %r0,[%sp,LP_START_LOC]
   ld   %r8,[%sp,R8_LOC]
   ld   %r9,[%sp,R9_LOC]
   sr   %r0,[LP_START]
   ld_s %r0,[%sp,LP_END_LOC]
   ld   %r10,[%sp,R10_LOC]
   ld   %r11,[%sp,R11_LOC]
   sr   %r0,[LP_END]
   ld_s %r12,[%sp,R12_LOC]
   ld   %r27,[%sp,R27_LOC]
   ; ld   %r60,[%sp,LP_COUNT_LOC]
   ld   %r0,[%sp,LP_COUNT_LOC]
   mov  %r60,%r0
.ifdef __Xmult32
   ld    %r0,[%sp,R57_LOC]
   ld    %r6,[%sp,R59_LOC]
   mulu64 0, %r0, 1
   ld    %r5,[%sp,R5_LOC]
   mov   0,%mlo
   sr    %r6,[0x12]
   ld    %r6,[%sp,R6_LOC]
.else
   ld    %r5,[%sp,R5_LOC]
   ld    %r6,[%sp,R6_LOC]
.endif

   ld_s  %r0,[%sp,ILINK1_LOC]
   flag  0                      ; STOP ALL INTERRUPTS
   mov_s %ILINK1,%r0
   ld_s  %r0,[%sp,FLAGS_LOC]
   sr    %r0,[STATUS32_L2]
.ifdef BTA_LOC
   ld    %r0,[%sp,BTA_LOC]
   sr    %r0,[bta_l2]
.endif
   ld_s  %r0,[%sp,RETURN_ADDRESS_LOC]
   mov_s %ILINK2,%r0
   ld_s  %r0,[%sp,R0_LOC]
.endm

.macro SAVE_REST_ISR_REGISTERS
   st_s %r13,[%sp,R13_LOC]
   st_s %r14,[%sp,R14_LOC]
   st_s %r15,[%sp,R15_LOC]
   st   %r16,[%sp,R16_LOC]
   st   %r17,[%sp,R17_LOC]
   st   %r18,[%sp,R18_LOC]
   st   %r19,[%sp,R19_LOC]
   st   %r20,[%sp,R20_LOC]
   st   %r21,[%sp,R21_LOC]
   st   %r22,[%sp,R22_LOC]
   st   %r23,[%sp,R23_LOC]
   st   %r24,[%sp,R24_LOC]
   st   %r25,[%sp,R25_LOC]
   st   %r26,[%sp,R26_LOC]
   add  %r0,%sp,R27_LOC
   SAVEX %R32,R32_LOC-R27_LOC,0x00000001
   SAVEX %R33,R33_LOC-R27_LOC,0x00000002
   SAVEX %R34,R34_LOC-R27_LOC,0x00000004
   SAVEX %R35,R35_LOC-R27_LOC,0x00000008
   SAVEX %R36,R36_LOC-R27_LOC,0x00000010
   SAVEX %R37,R37_LOC-R27_LOC,0x00000020
   SAVEX %R38,R38_LOC-R27_LOC,0x00000040
   SAVEX %R39,R39_LOC-R27_LOC,0x00000080
   SAVEX %R40,R40_LOC-R27_LOC,0x00000100
   SAVEX %R41,R41_LOC-R27_LOC,0x00000200
   SAVEX %R42,R42_LOC-R27_LOC,0x00000400
   SAVEX %R43,R43_LOC-R27_LOC,0x00000800
   SAVEX %R44,R44_LOC-R27_LOC,0x00001000
   SAVEX %R45,R45_LOC-R27_LOC,0x00002000
   SAVEX %R46,R46_LOC-R27_LOC,0x00004000
   SAVEX %R47,R47_LOC-R27_LOC,0x00008000
   SAVEX %R48,R48_LOC-R27_LOC,0x00010000
   SAVEX %R49,R49_LOC-R27_LOC,0x00020000
   SAVEX %R50,R50_LOC-R27_LOC,0x00040000
   SAVEX %R51,R51_LOC-R27_LOC,0x00080000
   SAVEX %R52,R52_LOC-R27_LOC,0x00100000
   SAVEX %R53,R53_LOC-R27_LOC,0x00200000
   SAVEX %R54,R54_LOC-R27_LOC,0x00400000
   SAVEX %R55,R55_LOC-R27_LOC,0x00800000
   SAVEX %R56,R56_LOC-R27_LOC,0x01000000
.ifndef __Xmult32
   SAVEX %R57,R57_LOC-R27_LOC,0x02000000
   SAVEX %R58,R58_LOC-R27_LOC,0x04000000
   SAVEX %R59,R59_LOC-R27_LOC,0x08000000
.endif
.endm
                
.macro RESTORE_REST_ISR_REGISTERS
   ld_s %r13,[%sp,R13_LOC]
   ld_s %r14,[%sp,R14_LOC]
   ld_s %r15,[%sp,R15_LOC]
   ld   %r16,[%sp,R16_LOC]
   ld   %r17,[%sp,R17_LOC]
   ld   %r18,[%sp,R18_LOC]
   ld   %r19,[%sp,R19_LOC]
   ld   %r20,[%sp,R20_LOC]
   ld   %r21,[%sp,R21_LOC]
   ld   %r22,[%sp,R22_LOC]
   ld   %r23,[%sp,R23_LOC]
   ld   %r24,[%sp,R24_LOC]
   ld   %r25,[%sp,R25_LOC]
   ld   %r26,[%sp,R26_LOC]
   LOADX %R32,R32_LOC,0x00000001
   LOADX %R33,R33_LOC,0x00000002
   LOADX %R34,R34_LOC,0x00000004
   LOADX %R35,R35_LOC,0x00000008
   LOADX %R36,R36_LOC,0x00000010
   LOADX %R37,R37_LOC,0x00000020
   LOADX %R38,R38_LOC,0x00000040
   LOADX %R39,R39_LOC,0x00000080
   LOADX %R40,R40_LOC,0x00000100
   LOADX %R41,R41_LOC,0x00000200
   LOADX %R42,R42_LOC,0x00000400
   LOADX %R43,R43_LOC,0x00000800
   LOADX %R44,R44_LOC,0x00001000
   LOADX %R45,R45_LOC,0x00002000
   LOADX %R46,R46_LOC,0x00004000
   LOADX %R47,R47_LOC,0x00008000
   LOADX %R48,R48_LOC,0x00010000
   LOADX %R49,R49_LOC,0x00020000
   LOADX %R50,R50_LOC,0x00040000
   LOADX %R51,R51_LOC,0x00080000
   LOADX %R52,R52_LOC,0x00100000
   LOADX %R53,R53_LOC,0x00200000
   LOADX %R54,R54_LOC,0x00400000
   LOADX %R55,R55_LOC,0x00800000
   LOADX %R56,R56_LOC,0x01000000
.ifndef __Xmult32
   LOADX %R57,R57_LOC,0x02000000
   LOADX %R58,R58_LOC,0x04000000
   LOADX %R59,R59_LOC,0x08000000
.endif
.endm

; This macro calls the kernel logging function, if logging enabled
.macro KLOG, KLOG_FUNCTION, KLOG_LABEL
   .if MQX_KERNEL_LOGGING    ; is MQX_KERNEL_LOGGING NE to 0
      ld    %r0,[%r2,KD_LOG_CONTROL]
      and.f 0,%r0,1
      beq_s L\&KLOG_LABEL
      mov_s %r0,%r4
      sub_s %sp,%sp,44       ; allocate back-trace memory, and reg space
      st_s  %r1,[%sp,16]
      st_s  %r2,[%sp,20]
      st_s  %r3,[%sp,24]
      st    %r4,[%sp,28]
      st    %r5,[%sp,32]
      st    %r6,[%sp,36]
      st    %r7,[%sp,40]
      jl    \&KLOG_FUNCTION
      ld_s  %r1,[%sp,16]
      ld_s  %r2,[%sp,20]
      ld_s  %r3,[%sp,24]
      ld    %r4,[%sp,28]
      ld    %r5,[%sp,32]
      ld    %r6,[%sp,36]
      ld    %r7,[%sp,40]
      add_s %sp,%sp,44
L\&KLOG_LABEL\&:
   .endif
.endm
        
; Start CR 2396
.if MQX_USE_PMU
;
; This macro calls the data cache flush function
.macro DCACHE_FLASH, DCACHE_FLUSH_FUNCTION
      jl    \&DCACHE_FLUSH_FUNCTION
.endm


.ifndef PSP_PMU_STATUS
.equ PSP_PMU_STATUS, 0x450
.endif

        .global   _ep_dvfs_adjust_time
        .global   _pmu_wakeup
.endif
; End CR 2396

;------------------------------------------------------------------------
;                         EXTERNAL REFERENCES
;

   .if MQX_KERNEL_LOGGING    ; is MQX_KERNEL_LOGGING NE to 0
        .global   _klog_block_internal
        .global   _klog_execute_scheduler_internal
        .global   _klog_yield_internal
        .global   _klog_context_switch_internal
        .global   _klog_isr_start_internal
        .global   _klog_isr_end_internal
; Start CR 2396
   .if MQX_USE_PMU
        .global   _klog_pmu_powerdown_start
        .global   _klog_pmu_powerdown_end
   .endif
; End CR 2396
   .endif

        .global   _mqx_kernel_data

; EOF

