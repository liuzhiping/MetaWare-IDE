/**********************************************************************
*    This file was generated by Design Tool a product of: 
*       ARC International  
*       http://www.ARC.com/         
*                              
*       Mon Mar 12 09:32:22 2007
*   
*       Copyright (c) ARC International  
*       All rights reserved    
*   
*       This software embodies materials and concepts which are
*       confidential to ARC International and is made
*       available solely pursuant to the terms of a written license
*       agreement with ARC International.
*   
*   ********************************************************************/

/*   Defines and data structures for application       */

#define MUTEXB_INDEX      5
#define MUTEXA_INDEX      6
#define SEMB_INDEX      7
#define SEMA_INDEX      8
#define EVENTB_INDEX      9
#define EVENTA_INDEX      10
#define BTIMESLICETASK_INDEX      11
#define ATIMESLICETASK_INDEX      12
#define SENDER_INDEX      13
#define RESPONDER_INDEX      14
#define MAIN_INDEX      15

#define    NO_TIMEOUT     0
#define   SIZE_UNLIMITED  0


/* Defines for Semaphore Component */
#define   SEM_INITIAL_NUMBER    10
#define   SEM_GROWTH            10
#define   SEM_MAXIMUM           20

/* Defines for Event Component */
#define   EVENT_INITIAL_NUMBER    10
#define   EVENT_GROWTH            10
#define   EVENT_MAXIMUM           20

/*
**   Externs for global data
*/
/*  Message Queue Ids */
extern   _queue_id   Sender_Queue_qid;
extern   _queue_id   Responder_Queue_qid;
extern   _queue_id   Main_Queue_qid;
/*  Message Pool Ids */
extern   _pool_id    MsgPool_pool_id;
/*  Mutex Definitions */
extern   MUTEX_STRUCT      Mutex1;

/*
** Externs for Tasks and ISRs
*/
extern void MutexB(uint_32);
extern void MutexA(uint_32);
extern void SemB(uint_32);
extern void SemA(uint_32);
extern void EventB(uint_32);
extern void EventA(uint_32);
extern void BTimeSliceTask(uint_32);
extern void ATimeSliceTask(uint_32);
extern void Sender(uint_32);
extern void Responder(uint_32);
extern void Main(uint_32);
extern void Loadfunction(uint_32);

#if MQX_USE_PMU
/* Definitions for Power Management */

/* DEMO_AUTO_DVFS defines weather we use an automatic DVFS mode */

#define DEMO_AUTO_DVFS 0

/* DEMO_GLOBAL_DVFS_MODE sets the DVFS Mode for tasks without a specific DVFS setting */
/* Auto and GLOBAL DVFS modes are mutually exclusive */

#if DEMO_AUTO_DVFS
#define DEMO_GLOBAL_DVFS_MODE 0
#else
#define DEMO_GLOBAL_DVFS_MODE 1  /* set to full power */
#endif


/* The demo has 4 tasks that can have task specific DVFS settings */
/* Each of these tasks can also have a user specified delay to */
/* simulate a load. This allows the user to change loads and power consumption */
/* to experiment with different scenarios */

/* Warning: Maximum delay value is 100 */

#define SENDER_DVFS_MODE    2
#define SENDER_DELAY        100

#define RESPONDER_DVFS_MODE 3
#define RESPONDER_DELAY     100

#define EVENTA_DVFS_MODE    4
#define EVENTA_DELAY        25

#define EVENTB_DVFS_MODE    1
#define EVENTB_DELAY        0

/* Delay used in all other tasks */

#define GDVFS_DELAY 20


/* DEMO_POWER_DOWN allows the example to power down the CPU when idle. */
/* MQX implements an idle task that runs as the lowest priority task */
/* It puts the CPU in sleep mode and waits for the system timer to interrupt */
/* Many times, the system will still be idle and return to the idle task */
/* When we are looping between the idle task and timer isr, after a specified */
/* number of times, will will power down instead of sleep. We will then also have */
/* the option to increase the system timer interval for longer power down periods */
/* In our example we use DEMO_POWER_DOWN to define how many timer/idle loops before we */
/* power down instead of just sleep a 0 means no Power Down*/

#define DEMO_POWER_DOWN 20

/* DEMO_SLOW_DOWN allows the systems periodic timer to be increased during Power Down */
/* Each time the system wakes from a power down mode with nothing to do it doubles */
/* the clock interval and powers down again. This repeats n number of times */
/* in our example, the value of DEMO_SLOW_DOWN defines how many times we double the clock */ 
/* This allows for longer power down intervals and greater power savings */
/* DEMO_SLOW_DOWN is not compatible with any DVFS modes */

#if DEMO_AUTO_DVFS || DEMO_GLOBAL_DVFS_MODE || SENDER_DVFS_MODE || RESPONDER_DVFS_MODE || EVENTA_DVFS_MODE || EVENTB_DVFS_MODE
#define DEMO_SLOW_DOWN 0
#else
#define DEMO_SLOW_DOWN 2
#endif

#else  /* No PMU */

#define DEMO_AUTO_DVFS 0

#define DEMO_GLOBAL_DVFS_MODE 0

#define SENDER_DVFS_MODE    0
#define SENDER_DELAY        0

#define RESPONDER_DVFS_MODE 0
#define RESPONDER_DELAY     0

#define EVENTA_DVFS_MODE    0
#define EVENTA_DELAY        0

#define EVENTB_DVFS_MODE    0
#define EVENTB_DELAY        0

#define DEMO_POWER_DOWN 0
#define DEMO_SLOW_DOWN 0

#define GDVFS_DELAY 0

#endif
/* End of File */
