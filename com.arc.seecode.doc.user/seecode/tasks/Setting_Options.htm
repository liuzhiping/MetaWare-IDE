<HTML>
<HEAD>
 <TITLE>Setting Options</TITLE>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <LINK rel="StyleSheet" href="../default.css">
</HEAD>
<BODY>

<H1>Setting debugger options</H1>

<P>Use the Debugger options dialog to set specific options for debugging your
  program. Options set when invoking the debugger using a command prompt will not appear in the Debugger Options or Target-Specific Options dialogs.</P>
<h2>Setting program options</h2>
<P><i>Note:</i> In order for changed options to take effect, you must restart
  the debugger after setting options.</P>
<p>Click the <b>Program Options</b> tab to set the following:</p>
<blockquote>
  <p><b>Program &amp; args</b></p>
  <p>Enter the full path of the program in the <b>Program &amp; args</b> field or
 click the <b>Browse</b> <img src="../images/browse.gif"> button to locate your executable.
 You can provide program arguments and additional debugger command-line arguments following
 the path. This is an optional field.</p>
  <p><b>Source path</b></p>
  <p>Set the directory where the source file is located in the <b>Source Path</b> 
    field. Click <b>Browse</b> <img src="../images/browse.gif"> to navigate and 
    select the source path directory.</p>
  <p><b>Directory translation</b></p>
  <p>Set the directory translation if your source tree is not the same as when the
    program was compiled. Enter a sequence of <i>old,new</i> pairs where <i>new</i> replaces <i>old</i> if <i>old</i> is a prefix of the directory of the file when compiled. Separate multiple pairs with a semicolon (Windows) or colon (UNIX and Linux).
</p>
  <p><b>Automatically execute to main</b></p>
  <p>If checked, the debugger will run to <code>main()</code> function on startup.</p>
  <p><b>Include local symbols from ELF symbol table</b></p>
  <p>If checked, the debugger uses local symbol information from the ELF symbol 
    table; otherwise it uses only the globals. If you've compiled with -g (for 
    debug) you do not need to worry about this value.</p>
  <p><b>Program is already present</b></p>
  <p>Check this to prevent the program from being downloaded to the target. Use 
    this if your program is already present on the target. For example, you are 
    debugging a program in ROM. If the processor is running, the debugger will 
    attempt to stop it.</p>
  <p><b>Verify program downloaded successfully</b></p>
  <p>If checked, the debugger re-reads memory after download to verify that the 
    download succeeded. You might use this if you suspect memory problems. Note 
    that it takes time to re-read memory from the target.</p>
  <p><b>Show register differences while instruction stepping</b></p>
  <p>Upon instruction single-stepping the debugger inspects the value of all registers 
    before and after, and shows you registers that have changed. This is useful 
    but incurs high register traffic to the target. If the IO to the target is 
    slow you may want to turn this feature off.</p>
  <p><b>Cache target memory</b></p>
  <p>If checked, the debugger does not read the same target memory twice between 
    execution events. This reduces traffic to the target. Turn this off if you 
    have volatile memory that you expect to change each time it is read. </p>
  <p><b>Read readonly from executable</b></p>
  <p>If checked, the debugger does not read code or read-only data from the target 
    memory; instead, it reads it from the executable file. This reduces traffic 
    to the target. If your program is overwriting readonly memory, debugger displays 
    such as the disassembly window may be inaccurate. Leave this off if you are 
    concerned your program may be overwriting readonly memory.</p>
  <p><b>Prefer software breakpoints</b></p>
  <p>
    If checked, the debugger will try to set a software breakpoint unless it is unable
    to write memory (e.g., ROM), in which case it tries to set a hardware breakpoint.
    Deselecting this box causes the debugger to try hardware breakpoints first.
    Hardware typically has a limited number of hardware breakpoints, and by default
    the debugger will try to set a software breakpoint.  
  </p>
  <p><b>Show possible breakpoints in source</b></p>
  <p>
    If selected, the Source display will show a graphic marker on every line of source
    where you can set a breakpoint. Deselect to hide the markers. 
  </p>
  <p><b>Restore breakpoints from last run of same program</b></p>
  <p>
    If selected, the debugger attempts to restore breakpoints from the last time
    you ran the this program using the debugger. Breakpoint location might appear to shift if you
    modify and reload the program. 
  </p>
  <p><b>RTOS Selection</b></p>
  <p>If your apllication is intended to be run an an embedded OS, select the correct 
    RTOS.<br>
  </p>
</blockquote>
<h2>Setting command-line options</h2>
<P>Click the <b>Command-Line Options</b> tab to set the following:</P>
<ul>
  <li>In the <b>Toggles to turn on</b> and <b>Toggles to turn off</b> fields,
    enter any toggles to enable or disable. Enter only the toggle name. See the
    <i>MetaWare Debugger User's Guide</i> for a list and description of all toggles.</li>
  <li>In the <b>Command-line options</b> field, enter and Command-line startup
    options. See the <i>MetaWare Debugger User's Guide</i> for a list and description
    of command-line options.</li>
  <li>Select <b>Enable Command Logging</b> and type or browse to the path and file name
      where you want the debugger to save the log file.</li>
  <li>Check <b>Enable profiling window</b> to enable profiling in debugger windows. 
    When checked, the debugger will provide a display you can use to obtain profiling
information including, but not limited to, the following:
<ul>
  <li>Instruction call counts</li>
  <li>Source code coverage</li>
  <li>Profiling interrupts</li>
</ul>
    This option will only work if the program was compiled with profiling 
    information enabled. </li>
</ul>
<h2>Setting user interface options</h2>
<P>Click the <b>GUI Options</b> tab to set the following:</P>
<ul>
  <li>Choose a font size for debugger windows using the <b>Font size</b> option.</li>
  <li>Enter a <b>Maximum aggregate display size</b>. The debugger displays the
    contents of aggregates (arrays and structs) up to a certain size. This parameter
    specifies that size; the default is 64K. If you have a slow communications
    link to the target you may wish to reduce this to a very small number.</li>
  <li>Various windows bring up other windows; for example, the Call Stack window 
    shows source or assembly corresponding to the stack position. Select <b>Reuse 
    Displays</b> to reuse an existing Source or Disassembly window by turning 
    on this toggle. This helps eliminate excessive windows in the debugger.</li>
</ul>
<h2>Adding a semantic inspection DLL</h2>
<P>You can add multiple semantic inspection interfaces to the debugger.</P>
<ol>
  <li>Click the <b>Semantic Inspection</b> tab.</li>
  <li>Click the <b>Browse </b><img src="../images/browse.gif"> button to select
    a DLL.</li>
</ol>
<P>See the <i>MetaWare Debugger User's Guide</i> for more information on creating
  and using semantic inspection interfaces.</P>
<p>&nbsp;</p>
</BODY>
</HTML>
